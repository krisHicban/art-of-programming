# ğŸ‘ï¸ OPENCV VIZIUNE COMPUTERIZATÄ‚ - SISTEM DE SUPRAVEGHERE & SIGURANÈšÄ‚

---

## ğŸ“š Introducere

Bine ai venit la **Viziune ComputerizatÄƒ** - unde codul tÄƒu Ã®nvaÈ›Äƒ sÄƒ "vadÄƒ" lumea!

Ãn acest capitol, vei descoperi cÄƒ imaginile sunt doar **array-uri NumPy deghizate**. Fiecare pixel este un numÄƒr, iar manipulÃ¢nd aceste numere, poÈ›i:
- ğŸ¨ **Detecta culori** (gÄƒseÈ™te toate obiectele albastre)
- ğŸ” **UrmÄƒri miÈ™carea** (observÄƒ schimbÄƒrile Ã®ntre cadre)
- ğŸš¨ **RecunoaÈ™te pattern-uri** (detecteazÄƒ fum, foc, feÈ›e)
- ğŸ“¹ **Construi sisteme Ã®n timp real** (supraveghere, alerte de siguranÈ›Äƒ)

La final, vei construi un **sistem real de supraveghere È™i siguranÈ›Äƒ contra incendiilor** folosind doar matematicÄƒ de pixeli È™i OpenCV!

---

## ğŸ¯ Ce este OpenCV?

**OpenCV** (Open Source Computer Vision Library) este standardul industriei pentru viziune computerizatÄƒ:

```
CamerÄƒ/Imagine â†’ Array NumPy â†’ Filtre OpenCV â†’ Insight-uri/AcÈ›iuni
      â†“              â†“              â†“              â†“
   Pixeli      [valori 0-255]  Algoritmi      Decizii
```

**Concepte cheie pe care le vei stÄƒpÃ¢ni:**
- **SpaÈ›ii de culoare**: RGB (ce vedem noi), HSV (mai uÈ™or de filtrat), Grayscale (doar forme)
- **Thresholding**: Convertirea imaginilor Ã®n binar (alb/negru) pe bazÄƒ de condiÈ›ii
- **Contururi**: GÄƒsirea marginilor obiectelor
- **DiferenÈ›a de cadre**: Detectarea a ceea ce s-a schimbat Ã®ntre douÄƒ imagini
- **OperaÈ›ii morfologice**: CurÄƒÈ›area zgomotului, umplerea golurilor

---

## ğŸš€ Setup & Instalare

AsigurÄƒ-te cÄƒ ai OpenCV instalat:
```bash
pip install opencv-python matplotlib numpy
```

**Test rapid:**
```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

print(f"Versiune OpenCV: {cv2.__version__}")

# CreeazÄƒ un pÄƒtrat roÈ™u de 100x100
red_square = np.zeros((100, 100, 3), dtype=np.uint8)
red_square[:, :] = [255, 0, 0]  # RGB: RoÈ™u

plt.imshow(red_square)
plt.title("Prima ta creaÈ›ie OpenCV!")
plt.axis('off')
plt.show()
```

**ğŸ’¡ AminteÈ™te-È›i:** Imaginile sunt doar array-uri 3D: `(Ã®nÄƒlÈ›ime, lÄƒÈ›ime, canale)`

---

# PARTEA 1: EXERCIÈšII DE ÃNCÄ‚LZIRE

---

## ğŸ“ EXERCIÈšIUL 1: Detector de Obiecte Albastre

**Obiectiv:** DetecteazÄƒ toate obiectele albastre dintr-o imagine folosind spaÈ›iul de culoare HSV

### ğŸ“– Concepte pe care le vei Ã®nvÄƒÈ›a:

**`SpaÈ›ii de culoare`**: Moduri diferite de a reprezenta culorile
- **RGB**: RoÈ™u-Verde-Albastru (0-255 fiecare) - cum vÄƒd camerele
- **HSV**: Hue-Saturation-Value - mai uÈ™or pentru detectarea culorilor
  - **Hue**: Culoarea propriu-zisÄƒ (0-180 Ã®n OpenCV)
  - **Saturation**: Intensitatea culorii (0-255)
  - **Value**: Luminozitatea (0-255)

**`cv2.inRange()`**: CreeazÄƒ o mascÄƒ unde pixelii Ã®n interval = alb (255), restul = negru (0)

**`cv2.findContours()`**: GÄƒseÈ™te marginile regiunilor albe Ã®n imagini binare

**`cv2.contourArea()`**: CalculeazÄƒ aria unui contur Ã®n pixeli

### ğŸ¯ Misiunea Ta:

1. ÃncarcÄƒ o imagine (fÄƒ o pozÄƒ cu telefonul tÄƒu cu obiecte colorate!)
2. ConverteÈ™te din BGR Ã®n spaÈ›iul de culoare HSV
3. CreeazÄƒ o mascÄƒ care izoleazÄƒ DOAR pixelii albaÈ™tri
4. GÄƒseÈ™te contururile (marginile) obiectelor albastre
5. FiltreazÄƒ zgomotul mic (pÄƒstreazÄƒ doar obiecte > 500 pixeli)
6. DeseneazÄƒ dreptunghiuri Ã®n jurul obiectelor albastre detectate
7. AfiÈ™eazÄƒ: imaginea originalÄƒ, masca, È™i detecÈ›ia finalÄƒ

### ğŸ’» Cod de Pornire:

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

# ÃncarcÄƒ imaginea (Ã®nlocuieÈ™te cu a ta!)
image = cv2.imread('your_image.jpg')
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

print(f"ğŸ“¸ Imagine Ã®ncÄƒrcatÄƒ: {image_rgb.shape}")

# TODO 1: ConverteÈ™te Ã®n HSV
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

# TODO 2: DefineÈ™te intervalul de culoare albastrÄƒ Ã®n HSV
# Albastru Ã®n HSV: Hue ~100-130, saturaÈ›ie mare, valoare decentÄƒ
lower_blue = np.array([100, 50, 50])    # AjusteazÄƒ acestea!
upper_blue = np.array([130, 255, 255])  # AjusteazÄƒ acestea!

# TODO 3: CreeazÄƒ masca
mask = cv2.inRange(hsv, lower_blue, upper_blue)

# TODO 4: GÄƒseÈ™te contururile
contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# TODO 5: FiltreazÄƒ È™i deseneazÄƒ
result = image_rgb.copy()
detected_count = 0

for contour in contours:
    area = cv2.contourArea(contour)

    if area > 500:  # FiltreazÄƒ zgomotul mic
        # ObÈ›ine dreptunghiul delimitat
        x, y, w, h = cv2.boundingRect(contour)

        # DeseneazÄƒ pe rezultat
        cv2.rectangle(result, (x, y), (x+w, y+h), (0, 255, 0), 3)
        cv2.putText(result, f"Albastru #{detected_count+1}", (x, y-10),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
        detected_count += 1

        print(f"   Obiect #{detected_count}: {int(area)} pixeli la ({x}, {y})")

print(f"\nâœ… Detectate {detected_count} obiecte albastre!")

# TODO 6: VizualizeazÄƒ rezultatele
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

axes[0].imshow(image_rgb)
axes[0].set_title('Imagine OriginalÄƒ')
axes[0].axis('off')

axes[1].imshow(mask, cmap='gray')
axes[1].set_title('MascÄƒ AlbastrÄƒ (Alb = Pixeli albaÈ™tri)')
axes[1].axis('off')

axes[2].imshow(result)
axes[2].set_title(f'DetecÈ›ie: {detected_count} obiecte albastre')
axes[2].axis('off')

plt.tight_layout()
plt.show()
```

### ğŸ’¡ Indicii:

- **GÄƒsirea intervalului HSV corect**: FoloseÈ™te trial and error! Intervale comune:
  - Albastru: `[100, 50, 50]` pÃ¢nÄƒ la `[130, 255, 255]`
  - Verde: `[40, 50, 50]` pÃ¢nÄƒ la `[80, 255, 255]`
  - RoÈ™u: `[0, 50, 50]` pÃ¢nÄƒ la `[10, 255, 255]` SAU `[170, 50, 50]` pÃ¢nÄƒ la `[180, 255, 255]`
- **Pro tip**: CreeazÄƒ un trackbar pentru a ajusta intervalele Ã®n timp real (avansat!)

### â“ ÃntrebÄƒri de ReflecÈ›ie:

**1. De ce folosim HSV Ã®n loc de RGB pentru detectarea culorilor?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

**2. Ce se Ã®ntÃ¢mplÄƒ dacÄƒ setezi `area > 100` Ã®n loc de `area > 500`?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

**3. Provocare: ModificÄƒ codul pentru a detecta obiecte ROÈ˜II. Ce se schimbÄƒ?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

---

## ğŸ“ EXERCIÈšIUL 2: ÃmbunÄƒtÄƒÈ›irea Textului Vechi cu Threshold Adaptiv

**Obiectiv:** FÄƒ textul vechi È™i decolorat lizibil din nou folosind thresholding adaptiv

### ğŸ“– Concepte pe care le vei Ã®nvÄƒÈ›a:

**`Thresholding`**: Convertirea imaginilor Ã®n tonuri de gri Ã®n alb/negru pur
- **Threshold global**: O singurÄƒ valoare pentru Ã®ntreaga imagine
- **Threshold adaptiv**: Valori diferite pentru regiuni diferite (mai bun pentru iluminare neuniformÄƒ!)

**`cv2.adaptiveThreshold()`**: Thresholding inteligent care gestioneazÄƒ umbrele È™i variaÈ›iile de luminÄƒ

**De ce conteazÄƒ:** Scanarea documentelor vechi, citirea bonurilor, preprocesarea OCR

### ğŸ¯ Misiunea Ta:

1. GÄƒseÈ™te o imagine cu text (paginÄƒ veche de carte, notÄƒ scrisÄƒ de mÃ¢nÄƒ, bon fiscal)
2. ConverteÈ™te Ã®n tonuri de gri
3. AplicÄƒ threshold obiÈ™nuit (global) - observÄƒ limitÄƒrile
4. AplicÄƒ threshold adaptiv - vezi magia!
5. ComparÄƒ rezultatele side-by-side

### ğŸ’» Cod de Pornire:

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

# ÃncarcÄƒ imagine cu text (fÄƒ o pozÄƒ la o paginÄƒ de carte!)
image = cv2.imread('old_text.jpg')
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

print(f"ğŸ“„ Imagine Ã®ncÄƒrcatÄƒ: {gray.shape}")

# TODO 1: AplicÄƒ threshold global
# Valoare threshold: 127 (mijlocul dintre 0-255)
_, global_thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

# TODO 2: AplicÄƒ threshold adaptiv (metoda Gaussian)
adaptive_thresh = cv2.adaptiveThreshold(
    gray,
    255,                              # Valoare maximÄƒ
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,   # MetodÄƒ
    cv2.THRESH_BINARY,                # Tip
    11,                               # Dimensiune bloc (trebuie sÄƒ fie impar!)
    2                                 # ConstantÄƒ C (scÄƒzutÄƒ din medie)
)

# TODO 3: ÃncearcÄƒ È™i metoda Mean
adaptive_mean = cv2.adaptiveThreshold(
    gray,
    255,
    cv2.ADAPTIVE_THRESH_MEAN_C,       # MetodÄƒ diferitÄƒ
    cv2.THRESH_BINARY,
    11,
    2
)

# VizualizeazÄƒ toate versiunile
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

axes[0, 0].imshow(gray, cmap='gray')
axes[0, 0].set_title('Original Tonuri de Gri')
axes[0, 0].axis('off')

axes[0, 1].imshow(global_thresh, cmap='gray')
axes[0, 1].set_title('Threshold Global (127)')
axes[0, 1].axis('off')

axes[1, 0].imshow(adaptive_thresh, cmap='gray')
axes[1, 0].set_title('Threshold Adaptiv (Gaussian)')
axes[1, 0].axis('off')

axes[1, 1].imshow(adaptive_mean, cmap='gray')
axes[1, 1].set_title('Threshold Adaptiv (Mean)')
axes[1, 1].axis('off')

plt.tight_layout()
plt.savefig('text_enhancement_comparison.png', dpi=150, bbox_inches='tight')
print("\nâœ… ComparaÈ›ie salvatÄƒ Ã®n: text_enhancement_comparison.png")
plt.show()

# CalculeazÄƒ scor de lizibilitate (euristicÄƒ simplÄƒ)
def calculate_readability(binary_image):
    """Scor mai mare = separare text/fundal mai bunÄƒ"""
    white_pixels = np.sum(binary_image == 255)
    black_pixels = np.sum(binary_image == 0)
    ratio = min(white_pixels, black_pixels) / max(white_pixels, black_pixels)
    return ratio * 100

print("\nğŸ“Š Scoruri de Lizibilitate:")
print(f"   Threshold global: {calculate_readability(global_thresh):.1f}/100")
print(f"   Adaptiv (Gaussian): {calculate_readability(adaptive_thresh):.1f}/100")
print(f"   Adaptiv (Mean): {calculate_readability(adaptive_mean):.1f}/100")
```

### ğŸ’¡ Indicii:

- **Dimensiune bloc**: Mai mare = mai neted (Ã®ncearcÄƒ 11, 15, 21, 31)
- **ConstantÄƒ C**: Valori pozitive fac imaginea mai luminoasÄƒ, negative = mai Ã®ntunecatÄƒ
- **TesteazÄƒ cu**: Bonuri vechi, poze la tablÄƒ albÄƒ, notiÈ›e scanate

### ğŸ“ Provocare AvansatÄƒ:

AplicÄƒ **operaÈ›ii morfologice** pentru a curÄƒÈ›a rezultatul:
```python
# EliminÄƒ zgomotul mic
kernel = np.ones((3, 3), np.uint8)
cleaned = cv2.morphologyEx(adaptive_thresh, cv2.MORPH_CLOSE, kernel)
cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_OPEN, kernel)
```

### â“ ÃntrebÄƒri de ReflecÈ›ie:

**1. De ce eÈ™ueazÄƒ threshold-ul global pe imagini cu iluminare neuniformÄƒ?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

**2. CÃ¢nd ai folosi threshold adaptiv GAUSSIAN vs MEAN?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

**3. AplicaÈ›ie din lumea realÄƒ: Cum ar putea ajuta acest lucru la OCR (recunoaÈ™terea textului)?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

---

## ğŸ“ EXERCIÈšIUL 3: Analiza Ariei Contururilor - GÄƒseÈ™te Obiecte Mari

**Obiectiv:** Extrage È™i analizeazÄƒ obiecte mai mari decÃ¢t o dimensiune specificÄƒ

### ğŸ“– Concepte pe care le vei Ã®nvÄƒÈ›a:

**`Contururi`**: Marginile formelor Ã®n imagini binare
**`OperaÈ›ii morfologice`**: OperaÈ›ii matematice pe imagini binare
- **Eroziune**: MicÈ™oreazÄƒ obiectele (eliminÄƒ zgomotul)
- **Dilatare**: MÄƒreÈ™te obiectele (umple golurile)
- **Opening**: Eroziune â†’ Dilatare (eliminÄƒ zgomotul mic)
- **Closing**: Dilatare â†’ Eroziune (umple gÄƒurile mici)

### ğŸ¯ Misiunea Ta:

1. ÃncarcÄƒ o imagine cu mai multe obiecte
2. ConverteÈ™te Ã®n binar (threshold)
3. GÄƒseÈ™te TOATE contururile
4. FiltreazÄƒ: pÄƒstreazÄƒ doar contururi > 500 pixeli
5. DeseneazÄƒ fiecare contur cu o culoare diferitÄƒ
6. AfiÈ™eazÄƒ aria, perimetrul È™i centroidul fiecÄƒrui obiect

### ğŸ’» Cod de Pornire:

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

# ÃncarcÄƒ imaginea
image = cv2.imread('objects.jpg')
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

print(f"ğŸ“¸ Imagine Ã®ncÄƒrcatÄƒ: {image_rgb.shape}")

# TODO 1: ConverteÈ™te Ã®n binar
_, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)

# TODO 2: CurÄƒÈ›Äƒ cu operaÈ›ii morfologice
kernel = np.ones((5, 5), np.uint8)
binary_clean = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
binary_clean = cv2.morphologyEx(binary_clean, cv2.MORPH_OPEN, kernel)

# TODO 3: GÄƒseÈ™te contururile
contours, _ = cv2.findContours(binary_clean, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

print(f"ğŸ” GÄƒsite {len(contours)} contururi totale")

# TODO 4: FiltreazÄƒ È™i analizeazÄƒ
result = image_rgb.copy()
large_objects = []

# GenereazÄƒ culori aleatorii pentru fiecare obiect
colors = [tuple(np.random.randint(0, 255, 3).tolist()) for _ in range(len(contours))]

for i, contour in enumerate(contours):
    area = cv2.contourArea(contour)

    if area > 500:  # Prag minim de arie
        # CalculeazÄƒ proprietÄƒÈ›i
        perimeter = cv2.arcLength(contour, True)

        # CalculeazÄƒ centroidul (centrul de masÄƒ)
        M = cv2.moments(contour)
        if M["m00"] != 0:
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])
        else:
            cx, cy = 0, 0

        # ObÈ›ine dreptunghiul delimitat
        x, y, w, h = cv2.boundingRect(contour)

        # StocheazÄƒ informaÈ›ii
        large_objects.append({
            'id': len(large_objects) + 1,
            'area': area,
            'perimeter': perimeter,
            'centroid': (cx, cy),
            'bbox': (x, y, w, h)
        })

        # DeseneazÄƒ conturul
        cv2.drawContours(result, [contour], -1, colors[i], 3)

        # DeseneazÄƒ centroidul
        cv2.circle(result, (cx, cy), 7, (255, 0, 0), -1)

        # DeseneazÄƒ caseta delimitatoare
        cv2.rectangle(result, (x, y), (x+w, y+h), (0, 255, 0), 2)

        # AdaugÄƒ etichetÄƒ
        cv2.putText(result, f"#{len(large_objects)}", (x, y-10),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 0), 2)

# AfiÈ™eazÄƒ analiza
print(f"\nâœ… GÄƒsite {len(large_objects)} obiecte mari (> 500 pixeli)\n")
print("ğŸ“Š Analiza Obiectelor:")
print("-" * 70)
for obj in sorted(large_objects, key=lambda x: x['area'], reverse=True):
    print(f"   Obiect #{obj['id']}:")
    print(f"      Arie: {int(obj['area'])} pixeli")
    print(f"      Perimetru: {int(obj['perimeter'])} pixeli")
    print(f"      Centroid: {obj['centroid']}")
    print(f"      CasetÄƒ delimitatoare: {obj['bbox']}")
    print()

# VizualizeazÄƒ
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

axes[0].imshow(image_rgb)
axes[0].set_title('Imagine OriginalÄƒ')
axes[0].axis('off')

axes[1].imshow(binary_clean, cmap='gray')
axes[1].set_title('Binar (DupÄƒ Morfologie)')
axes[1].axis('off')

axes[2].imshow(result)
axes[2].set_title(f'Detectate: {len(large_objects)} obiecte')
axes[2].axis('off')

plt.tight_layout()
plt.show()
```

### ğŸ’¡ Indicii:

- **ExperimenteazÄƒ cu threshold**: ÃncearcÄƒ adaptiv Ã®n loc de global
- **Dimensiunea kernel conteazÄƒ**: Kernel mai mare = netezire mai agresivÄƒ
- **RETR_EXTERNAL**: Doar contururile exterioare (foloseÈ™te RETR_TREE pentru cele imbricate)

### â“ ÃntrebÄƒri de ReflecÈ›ie:

**1. Care este diferenÈ›a Ã®ntre arie È™i perimetru? CÃ¢nd este utilÄƒ fiecare?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

**2. De ce avem nevoie de operaÈ›ii morfologice Ã®nainte de a gÄƒsi contururi?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

**3. Provocare: Cum ai identifica cercuri vs dreptunghiuri folosind contururi?**

_RÄƒspunsul tÄƒu:_ _______________________________________________

---

# PARTEA 2: PROIECT FINAL - SISTEM DE SUPRAVEGHERE & SIGURANÈšÄ‚ CONTRA INCENDIILOR

---

## ğŸš¨ PROIECT: Sistem de Supraveghere Ã®n Timp Real & DetecÈ›ie Fum

**Obiectiv:** ConstruieÈ™te un sistem complet de securitate care detecteazÄƒ:
1. **IntruÈ™i**: DetecÈ›ia miÈ™cÄƒrii prin diferenÈ›a de cadre
2. **Pericole de incendiu**: DetecÈ›ia fumului prin analiza culorii È™i pattern-urilor

Aceasta este o **aplicaÈ›ie din lumea realÄƒ** care combinÄƒ tot ce ai Ã®nvÄƒÈ›at!

---

## ğŸ“‹ CerinÈ›e Sistem

Sistemul tÄƒu trebuie sÄƒ:

### ğŸ¯ FuncÈ›ionalitÄƒÈ›i de BazÄƒ:

1. **Stream Webcam**: CaptureazÄƒ video live de la camerÄƒ
2. **DetecÈ›ie MiÈ™care**:
   - ComparÄƒ cadrele consecutive
   - CalculeazÄƒ diferenÈ›ele de pixeli
   - DeclanÈ™eazÄƒ alarma cÃ¢nd schimbÄƒrile depÄƒÈ™esc pragul
   - DeseneazÄƒ casete delimitatoare Ã®n jurul obiectelor Ã®n miÈ™care
3. **DetecÈ›ie Fum**:
   - AnalizeazÄƒ culorile cadrului (fum = gradient gri/alb)
   - UrmÄƒreÈ™te pattern-ul de rÄƒspÃ¢ndire (fumul se ridicÄƒ È™i se extinde)
   - DetecteazÄƒ schimbÄƒri graduale de culoare pe mai multe cadre
4. **Sistem de AlarmÄƒ**:
   - Alerte vizuale (bordurÄƒ roÈ™ie intermitentÄƒ)
   - Avertismente Ã®n consolÄƒ cu timestamp-uri
   - SalveazÄƒ capturi de ecran ale evenimentelor

### ğŸ† FuncÈ›ionalitÄƒÈ›i Avansate (OpÈ›ional):

- IgnorÄƒ miÈ™cÄƒri mici (animale de companie, umbre)
- Monitorizare pe zone (sensibilitate diferitÄƒ pe zonÄƒ)
- Logging evenimente Ã®n fiÈ™ier
- Alerte email/SMS (folosind `smtplib` sau Twilio)

---

## ğŸ§  Abordare TehnicÄƒ

### Partea A: Algoritmul de DetecÈ›ie MiÈ™care

```
Pas 1: CaptureazÄƒ cadru_t È™i cadru_t-1
Pas 2: ConverteÈ™te ambele Ã®n tonuri de gri
Pas 3: CalculeazÄƒ |cadru_t - cadru_t-1| = hartÄƒ_diferenÈ›e
Pas 4: AplicÄƒ threshold â†’ hartÄƒ binarÄƒ
Pas 5: GÄƒseÈ™te contururi Ã®n harta binarÄƒ
Pas 6: FiltreazÄƒ contururi dupÄƒ arie â†’ schimbÄƒri mari = miÈ™care!
Pas 7: DacÄƒ total_pixeli_schimbaÈ›i > PRAG_MIÈ˜CARE â†’ ALERTÄ‚!
```

**Insight cheie:** Corpurile sunt obiecte mari, deci concentreazÄƒ-te pe contururi > 1000 pixeli

### Partea B: Algoritmul de DetecÈ›ie Fum

```
Pas 1: ConverteÈ™te cadrul Ã®n HSV
Pas 2: DefineÈ™te intervalul de culoare fum (gri/alb: saturaÈ›ie scÄƒzutÄƒ, valoare mare)
Pas 3: CreeazÄƒ mascÄƒ fum
Pas 4: UrmÄƒreÈ™te aria de fum pe ultimele N cadre
Pas 5: DacÄƒ aria_fum CREÈ˜TE Ã®n timp â†’ ALERTÄ‚ FOC!
Pas 6: Bonus: VerificÄƒ dacÄƒ fumul "se ridicÄƒ" (coordonatele y scad)
```

**Insight cheie:** Fumul are:
- SaturaÈ›ie scÄƒzutÄƒ (nu este colorat)
- Valoare mare (luminos/deschis)
- Pattern de extindere (creÈ™te pe cadre)
- MiÈ™care ascendentÄƒ (se deplaseazÄƒ Ã®n sus)

---

## ğŸ’» Cod de Pornire Proiect

### Partea 1: Doar DetecÈ›ie MiÈ™care

```python
import cv2
import numpy as np
from datetime import datetime

# Configurare
MOTION_THRESHOLD = 2000  # Pixeli schimbaÈ›i pentru a declanÈ™a alarma
MIN_CONTOUR_AREA = 1000  # Dimensiune minimÄƒ obiect (filtreazÄƒ zgomotul)

# IniÈ›ializeazÄƒ webcam
cap = cv2.VideoCapture(0)
ret, previous_frame = cap.read()
previous_gray = cv2.cvtColor(previous_frame, cv2.COLOR_BGR2GRAY)
previous_gray = cv2.GaussianBlur(previous_gray, (21, 21), 0)

print("ğŸ¥ Sistem de Supraveghere PorneÈ™te...")
print(f"   Prag miÈ™care: {MOTION_THRESHOLD} pixeli")
print(f"   Dimensiune min obiect: {MIN_CONTOUR_AREA} pixeli")
print("\nApasÄƒ 'q' pentru a ieÈ™i\n")

alarm_active = False

while True:
    ret, frame = cap.read()
    if not ret:
        break

    # TODO 1: PregÄƒteÈ™te cadrul curent
    current_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    current_gray = cv2.GaussianBlur(current_gray, (21, 21), 0)

    # TODO 2: CalculeazÄƒ diferenÈ›a de cadre
    frame_diff = cv2.absdiff(previous_gray, current_gray)

    # TODO 3: Threshold pe diferenÈ›Äƒ
    _, thresh = cv2.threshold(frame_diff, 25, 255, cv2.THRESH_BINARY)

    # TODO 4: DilateazÄƒ pentru a umple golurile
    thresh = cv2.dilate(thresh, None, iterations=2)

    # TODO 5: GÄƒseÈ™te contururile
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # TODO 6: AnalizeazÄƒ miÈ™carea
    motion_detected = False
    total_motion_area = 0

    for contour in contours:
        area = cv2.contourArea(contour)

        if area > MIN_CONTOUR_AREA:
            motion_detected = True
            total_motion_area += area

            # DeseneazÄƒ caseta delimitatoare
            x, y, w, h = cv2.boundingRect(contour)
            cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)

    # TODO 7: DeclanÈ™eazÄƒ alarma
    if total_motion_area > MOTION_THRESHOLD:
        if not alarm_active:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print(f"ğŸš¨ MIÈ˜CARE DETECTATÄ‚! [{timestamp}] - {int(total_motion_area)} pixeli schimbaÈ›i")
            alarm_active = True

            # SalveazÄƒ capturÄƒ
            cv2.imwrite(f'motion_{timestamp.replace(":", "-")}.jpg', frame)

        # AlarmÄƒ vizualÄƒ
        cv2.rectangle(frame, (0, 0), (frame.shape[1], frame.shape[0]), (0, 0, 255), 10)
        cv2.putText(frame, "!!! ALERTA MISCARE !!!", (50, 50),
                   cv2.FONT_HERSHEY_SIMPLEX, 1.5, (0, 0, 255), 3)
    else:
        alarm_active = False

    # TODO 8: AfiÈ™eazÄƒ informaÈ›ii
    cv2.putText(frame, f"Miscare: {int(total_motion_area)} px", (10, frame.shape[0] - 10),
               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

    # AratÄƒ feed-urile
    cv2.imshow('Sistem Supraveghere', frame)
    cv2.imshow('MascÄƒ MiÈ™care', thresh)

    # ActualizeazÄƒ cadrul anterior
    previous_gray = current_gray

    # IeÈ™ire la 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
print("\nâœ… Sistem de Supraveghere Oprit")
```

---

### Partea 2: Sistem Complet cu DetecÈ›ie Fum

**SARCINA TA:** Extinde codul de mai sus pentru a include detecÈ›ia fumului!

```python
# AdaugÄƒ dupÄƒ detecÈ›ia miÈ™cÄƒrii (Ã®n interiorul buclei while)

# TODO: IMPLEMENTARE DETECÈšIE FUM

# 1. ConverteÈ™te cadrul Ã®n HSV
hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

# 2. DefineÈ™te intervalul de culoare pentru fum
# Caracteristicile fumului Ã®n HSV:
#   - Hue: Oricare (0-180)
#   - Saturation: SCÄ‚ZUTÄ‚ (0-50) - nu foarte colorat
#   - Value: MARE (200-255) - luminos/deschis
lower_smoke = np.array([0, 0, 200])      # TODO: AjusteazÄƒ aceste valori!
upper_smoke = np.array([180, 50, 255])   # TODO: AjusteazÄƒ aceste valori!

# 3. CreeazÄƒ mascÄƒ fum
smoke_mask = cv2.inRange(hsv, lower_smoke, upper_smoke)

# 4. CurÄƒÈ›Äƒ zgomotul
kernel = np.ones((5, 5), np.uint8)
smoke_mask = cv2.morphologyEx(smoke_mask, cv2.MORPH_CLOSE, kernel)
smoke_mask = cv2.morphologyEx(smoke_mask, cv2.MORPH_OPEN, kernel)

# 5. CalculeazÄƒ aria de fum
smoke_pixels = np.sum(smoke_mask > 0)

# TODO: UrmÄƒreÈ™te fumul Ã®n timp (foloseÈ™te o listÄƒ pentru a stoca ultimele 10 cadre)
# smoke_history = []  # IniÈ›ializeazÄƒ Ã®nainte de buclÄƒ
# smoke_history.append(smoke_pixels)
# if len(smoke_history) > 10:
#     smoke_history.pop(0)

# 6. VerificÄƒ pattern-ul de fum Ã®n extindere
SMOKE_THRESHOLD = 5000  # AjusteazÄƒ pe baza testÄƒrii
smoke_detected = smoke_pixels > SMOKE_THRESHOLD

# TODO: Avansat - verificÄƒ dacÄƒ fumul CREÈ˜TE
# if len(smoke_history) >= 5:
#     recent_avg = np.mean(smoke_history[-5:])
#     old_avg = np.mean(smoke_history[:5])
#     if recent_avg > old_avg * 1.5:  # CreÈ™tere de 50%
#         smoke_detected = True

# 7. AlarmÄƒ de incendiu!
if smoke_detected:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"ğŸ”¥ FUM DETECTAT! [{timestamp}] - {int(smoke_pixels)} pixeli de fum")

    # AlarmÄƒ vizualÄƒ
    cv2.rectangle(frame, (0, 0), (frame.shape[1], frame.shape[0]), (0, 100, 255), 15)
    cv2.putText(frame, "!!! ALERTA FOC !!!", (50, 100),
               cv2.FONT_HERSHEY_SIMPLEX, 2, (0, 100, 255), 4)

    # SalveazÄƒ capturÄƒ
    cv2.imwrite(f'smoke_{timestamp.replace(":", "-")}.jpg', frame)

# 8. AfiÈ™eazÄƒ informaÈ›ii fum
cv2.putText(frame, f"Fum: {int(smoke_pixels)} px", (10, frame.shape[0] - 40),
           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

# AratÄƒ masca de fum
cv2.imshow('DetecÈ›ie Fum', smoke_mask)
```

---

## ğŸ§ª Testarea Sistemului TÄƒu

### Testarea DetecÈ›iei MiÈ™care:
1. PorneÈ™te programul
2. Stai nemiÈ™cat 3 secunde
3. FluturaÈ›i mÃ¢na Ã®n faÈ›a camerei
4. Mergi peste cadru
5. **AÈ™teptat**: Casete verzi Ã®n jurul tÄƒu, bordurÄƒ de alertÄƒ roÈ™ie

### Testarea DetecÈ›iei Fum:
Deoarece fumul real este periculos, simuleazÄƒ-l:
1. **Test hÃ¢rtie albÄƒ**: MiÈ™cÄƒ Ã®ncet o hÃ¢rtie albÄƒ/gri Ã®n sus
2. **Test lanternÄƒ**: LumineazÄƒ prin È›esÄƒturÄƒ albÄƒ
3. **Abur (sigur)**: Fierbe apÄƒ È™i captureazÄƒ aburul care se ridicÄƒ
4. **Test imagine**: AfiÈ™eazÄƒ imagine cu fum pe ecranul telefonului, miÈ™cÄƒ-l

**ğŸ’¡ Pro tip:** AjusteazÄƒ pragurile pe baza iluminÄƒrii mediului tÄƒu!

---

## ğŸ“Š Livrabile

Submission-ul tÄƒu final ar trebui sÄƒ includÄƒ:

```
opencv_surveillance_project/
â”œâ”€â”€ surveillance_system.py          # Cod principal
â”œâ”€â”€ test_results/
â”‚   â”œâ”€â”€ motion_2024-12-30_14-23-10.jpg
â”‚   â”œâ”€â”€ smoke_2024-12-30_14-25-33.jpg
â”‚   â””â”€â”€ screenshots.png (toate cele 4 ferestre)
â”œâ”€â”€ README.md                       # DocumentaÈ›ie proiect
â””â”€â”€ reflection_answers.md
```

### README.md ar trebui sÄƒ conÈ›inÄƒ:
- **Cum sÄƒ rulezi** sistemul
- **Valorile pragurilor** pe care le-ai folosit (È™i de ce)
- **Metodologia de testare** (cum ai testat miÈ™carea/fumul)
- **ProvocÄƒrile Ã®ntÃ¢mpinate** È™i soluÈ›ii
- **Link video demo** (opÈ›ional dar impresionant!)

---

## â“ ÃntrebÄƒri Finale de ReflecÈ›ie

### 1. ExplicÄƒ cum diferenÈ›a de cadre detecteazÄƒ miÈ™carea. De ce folosim diferenÈ›a absolutÄƒ?

_RÄƒspunsul tÄƒu:_
_______________________________________________________________
_______________________________________________________________

### 2. Ce face detecÈ›ia fumului mai dificilÄƒ decÃ¢t detecÈ›ia miÈ™cÄƒrii?

_RÄƒspunsul tÄƒu:_
_______________________________________________________________
_______________________________________________________________

### 3. Cum ai reduce alarmele false (de ex., ignorÄƒ umbrele, schimbÄƒrile de luminÄƒ)?

_RÄƒspunsul tÄƒu:_
_______________________________________________________________
_______________________________________________________________

### 4. Sistemul tÄƒu prinde un intrus la ora 3 dimineaÈ›a. Ce funcÈ›ionalitÄƒÈ›i suplimentare l-ar face mai util?

_RÄƒspunsul tÄƒu:_
_______________________________________________________________
_______________________________________________________________

### 5. Implementare Ã®n lumea realÄƒ: Care sunt consideraÈ›iile etice ale sistemelor de supraveghere?

_RÄƒspunsul tÄƒu:_
_______________________________________________________________
_______________________________________________________________

---

## ğŸ“ Rubrica de Evaluare

| Criteriu | Puncte | Descriere |
|-----------|--------|-------------|
| **DetecÈ›ie MiÈ™care** | 30 | DetecteazÄƒ È™i evidenÈ›iazÄƒ corect miÈ™carea |
| **DetecÈ›ie Fum** | 30 | IdentificÄƒ pattern-uri asemÄƒnÄƒtoare fumului |
| **Calitate Cod** | 15 | Curat, comentat, organizat |
| **Testare** | 10 | Proces de testare documentat cu capturi de ecran |
| **Alarme** | 10 | Alerte vizuale + log-uri Ã®n consolÄƒ funcÈ›ionale |
| **ReflecÈ›ie** | 5 | RÄƒspunsuri gÃ¢ndite la Ã®ntrebÄƒri |
| **FuncÈ›ionalitÄƒÈ›i Bonus** | +10 | Logging evenimente, zone multiple, alerte email, etc. |

**Total: 100 puncte** (+ 10 bonus)

---

## ğŸ’¡ Resurse Utile

- **DocumentaÈ›ie OpenCV**: https://docs.opencv.org/4.x/
- **Convertor spaÈ›iu culoare**: https://colorizer.org/
- **Selector culori HSV**: https://alloyui.com/examples/color-picker/hsv
- **Tutorial diferenÈ›Äƒ cadre**: https://www.pyimagesearch.com/2015/05/25/basic-motion-detection-and-tracking-with-python-and-opencv/
- **OperaÈ›ii morfologice**: https://docs.opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html

---

## ğŸ”¥ ProvocÄƒri Extra (Pentru Cei CurajoÈ™i!)

### Provocare 1: Integrare DetecÈ›ie FeÈ›e
AdaugÄƒ recunoaÈ™terea feÈ›ei pentru a identifica persoane autorizate vs neautorizate:
```python
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
faces = face_cascade.detectMultiScale(gray, 1.1, 4)
# DacÄƒ faÈ›a detectatÄƒ dar nu Ã®n lista autorizatÄƒ â†’ ALERTÄ‚ INTRUS
```

### Provocare 2: Monitorizare BazatÄƒ pe Zone
DefineÈ™te regiuni specifice (de ex., uÈ™Äƒ, fereastrÄƒ) cu sensibilitÄƒÈ›i diferite:
```python
zones = {
    'usa': {'bbox': (0, 0, 200, 480), 'threshold': 1000},
    'fereastra': {'bbox': (400, 0, 640, 300), 'threshold': 2000}
}
```

### Provocare 3: DetecÈ›ie Fum BazatÄƒ pe ML
AntreneazÄƒ o reÈ›ea neuronalÄƒ micÄƒ pentru a clasifica fum vs non-fum:
```python
# FoloseÈ™te keras/tensorflow cu dataset fum/fÄƒrÄƒ-fum
# Mult mai precis decÃ¢t detecÈ›ia bazatÄƒ pe culoare!
```

---

## âœ… Lista de Verificare FinalÄƒ

Ãnainte de submission, verificÄƒ:

- [ ] DetecÈ›ia miÈ™cÄƒrii funcÈ›ioneazÄƒ È™i declanÈ™eazÄƒ alarme
- [ ] DetecÈ›ia fumului identificÄƒ pattern-uri asemÄƒnÄƒtoare fumului
- [ ] Ambele sisteme pot rula simultan
- [ ] Capturile sunt salvate corect
- [ ] Log-urile Ã®n consolÄƒ aratÄƒ timestamp-uri
- [ ] Codul este bine comentat
- [ ] Testat cu scenarii multiple
- [ ] Valorile pragurilor sunt documentate
- [ ] ÃntrebÄƒrile de reflecÈ›ie au rÄƒspuns
- [ ] README.md este complet

---

**ğŸ‰ FelicitÄƒri! ğŸ‰**

Ai construit un **sistem real de supraveghere** folosind doar pixeli È™i matematicÄƒ. Aceasta este fundaÈ›ia:
- ğŸ  Securitate pentru casa inteligentÄƒ
- ğŸ­ Monitorizare siguranÈ›Äƒ industrialÄƒ
- ğŸš— PercepÈ›ie vehicul autonom
- ğŸ“± FuncÈ›ionalitÄƒÈ›i camerÄƒ mobilÄƒ
- ğŸ¤– Sisteme de viziune roboÈ›i

**AminteÈ™te-È›i:** Viziunea computerizatÄƒ este doar **array-uri NumPy + algoritmi inteligenÈ›i**. Acum ai instrumentele pentru a face computerele sÄƒ vadÄƒ!

---

*"Camera este un instrument care Ã®i Ã®nvaÈ›Äƒ pe oameni cum sÄƒ vadÄƒ fÄƒrÄƒ camerÄƒ."* - Dorothea Lange

**Acum du-te È™i construieÈ™te ceva care vede lumea diferit!** ğŸ‘ï¸âœ¨
